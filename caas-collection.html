<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../caas-crud-behavior/caas-crud-behavior.html">
<link rel="import" href="../caas-document/caas-document.html">

<!--
`caas-collection`


@demo demo/index.html 
-->

<dom-module id="caas-collection">
  <template>

      <iron-ajax
        id="readDocuments"
        headers="[[_requestHeaders]]"
        url="[[apiEndpoint]]/[[route]]"
        method="GET"
        last-response="{{documents}}"
        debounce-duration="[[debounceDuration]]"
        auto="[[autoRead]]"
        loading="{{reading}}"
        on-response="_handleReadResponse"
        on-error="_handleReadResponseError"
      ></iron-ajax>

      <template is="dom-repeat" items="{{documents}}" as="document">
        <caas-document
          api-endpoint="[[apiEndpoint]]"
          access-token="[[accessToken]]"
          auth="[[auth]]"
          route="[[route]]/[[document.id]]"
          debounce-duration="[[debounceDuration]]"
          document="{{document}}"
          auto-update="[[autoUpdate]]"
          on-updated="_handleDocumentUpdated"
          on-update-error="_handleDocumentUpdateError"
        ></caas-document>
      </template>

      <iron-ajax
        id="createDocument"
        headers="[[_requestHeaders]]"
        url="[[apiEndpoint]]/[[route]]"
        method="POST"
        loading="{{creating}}"
        on-response="_handleCreateResponse"
        on-error="_handleCreateResponseError"
      ></iron-ajax>      

      <!--TODO Deze hier of in document?-->
      <iron-ajax
        id="deleteDocument"
        headers="[[_requestHeaders]]"
        method="DELETE"
        loading="{{deleting}}"
        on-response="_handleDeleteResponse"
        on-error="_handleDeleteResponseError"
      ></iron-ajax>

  </template>
  <script>
    Polymer({

      is: 'caas-collection',
      behaviors: [CaasCrudBehavior],

      properties: {

        /**
        * The documents array
        */
        documents: {
          type: Array,
          value: [],
          notify: true
        },

        hasChanges: {
          type: Boolean,
          computed: '_computeHasChanges(unsavedDocuments.updates.splices)',
          observer: '_hasChangesChanged',
          notify: true
        },

        unsavedDocuments: {
          type: Object,
          value: {
            creations: [],
            updates: [],
            deletions: []
          },
          notify: true
        },

        trackChanges: {
          type: Boolean,
          value: false
        },

        updateInterval: {
          type: Number,
          value: 3000
        },

        _shadowDocuments: {
          type: Array,
          value: []
        },

        _updateTimer: {
          type: Object
        },

      },

      observers: [
        '_resetUpdateInterval(trackChanges, autoUpdate, updateInterval)',
        '_documentsChanged(documents.splices)'
      ],

      read: function() {
        this._sendAjaxRequest('read');
      },

      save: function() {
        this._diffDocuments();
        this.attemptSyncUnsavedDeletions()
        this.attemptSyncUnsavedCreations()
        for(var i=0;i<this.unsavedDocuments.updates.length;i++) {
          this.updateItem(i);
        }
      },

      attemptSyncUnsavedDeletions: function () {
        var deletionsArray = this.unsavedDocuments.deletions;
        for(var i=0;i< deletionsArray.length;i++) {
          // TODO: has to wait on Ajax response before changing url
          // this.$.deleteDocument.url = this.apiEndpoint + '/' + this.route + '/' + deletionsArray[i].id;                              
          // this.delete(deletionsArray[i], i)
        }        
      },

      attemptSyncUnsavedCreations: function () {
        var creationssArray = this.unsavedDocuments.creations;
        for(var i=0;i< creationssArray.length;i++) {
          this._sendAjaxRequest('create', creationssArray[i]);
        }        
      },      

      _handleDocumentUpdated: function(evt) {
        var documentId = evt.target.document.id;
        var unsavedDocumentsUpdatesIds = this._getUnsavedDocumentIds('updates');
        var existingIndex = unsavedDocumentsUpdatesIds.indexOf(documentId);
        if(existingIndex !== -1) {
          this._removeUnsavedDocument('updates', this.unsavedDocuments.updates[existingIndex]);
        }
      },

      _documentsChanged: function (documentsSplices) {
        if (documentsSplices) {
          var indexSplices = documentsSplices.indexSplices;

          // indexSplices.length is always 1
          var changes = indexSplices[0];

          this._handleRemovedDocuments(changes.removed, changes.index)
          this._handleAddedDocuments(changes.addedCount, changes.index, changes.object)
        }
      },   

      _handleRemovedDocuments: function (deletedDocuments, index) {
        // Multiple documents can be removed with one splice
        deletedDocuments.forEach(function(deletedDocument, i) {
          var removedIndex = index + i;

          this._addUnsavedDocument('deletions', deletedDocument, removedIndex);

          // TODO -> in collections or in document? 
          this.$.deleteDocument.url = this.apiEndpoint + '/' + this.route + '/' + deletedDocument.id;                              
          this.delete(deletedDocument, removedIndex)
        }, this);
      },      

      /**
      * Delete `document`
      */
      delete: function(deletedDocument, removedIndex) {
        this._addUnsavedDocument('deletions', deletedDocument, removedIndex);          
        this._sendAjaxRequest('delete');
      },                   

      _handleDeleteResponse: function (evt, deleteRequest) {
        this.fire('deleted');


        var id = this._getDocumentIdFromAjaxRequest(deleteRequest)
        this._removeUnsavedDocument('deletions', this.unsavedDocuments.deletions[id]);
      },

      _handleDeleteResponseError: function(evt, failedDeleteRequest) {
        this._fireErrorEvent('delete', 'deletions', failedDeleteRequest)
      },      

      _handleAddedDocuments: function (addedCount, index, documents) {
        for (var i=0; i < addedCount; i++) {
          var addedIndex = index + i;
          var newDocument = documents[addedIndex];

          // if newDoc has an id, it's already somewhere in the database
          if(!newDocument.id) {

            // TODO newDocument.id has no id at this point!
            this._addUnsavedDocument('creations', newDocument, addedIndex);          
            return this._sendAjaxRequest('create', newDocument);
          }
        }
      },
         
      _handleCreateResponse: function(evt, creationRequest) {
        this.fire('created');
        
        var createdDocumentId = this._getDocumentIdFromAjaxRequest(creationRequest)
        this._removeUnsavedDocument('creations', this.unsavedDocuments.creations[createdDocumentId]);
        
      },      

      _handleCreateResponseError: function(evt, failedCreationRequest) {
        this._fireErrorEvent('create', 'creations', failedCreationRequest)
      },          

      updateItem: function(i) {
        var documentIndex = this.unsavedDocuments.updates[i].index;
        var caasDoc = this.querySelectorAll('caas-document')[documentIndex];
        caasDoc.notifyProperties();
        caasDoc.update();
      },

      // TODO more information?
      _handleDocumentUpdate: function(evt) {
        this.fire('updated');        
      },      

      _handleDocumentUpdateError: function(evt, updateRequest) {
        this._fireErrorEvent('update', 'updates', updateRequest)
      },   

      _computeHasChanges: function(unsavedDocumentsSplices) {
        for(var changeCategory in this.unsavedDocuments) {
          if(this.unsavedDocuments[changeCategory].length > 0) return true;
        }
        return false;
      },

      _hasChangesChanged: function(hasChanges) {
        if(hasChanges && this.autoUpdate) {
          this.save();
        }
      },

      _diffDocuments: function() {
        if(!this._shadowDocuments || this._shadowDocuments.length === 0) {
          this.set('_shadowDocuments', []);
          for(var i=0;i<this.documents.length;i++) {
            this._shadowDocuments.push(JSON.stringify(this.documents[i]));
          }
        } else {
          for(var i=0;i<this.documents.length;i++) {
            this._diffItem(i);
          }          
        }
      },

      _diffItem: function(i) {
        var masterDocument = JSON.stringify(this.documents[i]);
        var shadowDocument = this._shadowDocuments[i];
        var documentId = this.documents[i].id;

        if(masterDocument !== shadowDocument) {
          this._addUnsavedDocument('updates', documentId, i);
          this._shadowDocuments[i] = masterDocument;
        }
      },

      _addUnsavedDocument: function(changeCategory, newUnsavedDoc, i) {
        var existingIndex = this._computeUnsavedDocumentIndex(changeCategory, newUnsavedDoc.id);
        if(existingIndex === -1) {
          this.push('unsavedDocuments.' + changeCategory , {
            index: i,
            id: newUnsavedDoc.id,
            doc: newUnsavedDoc
          });
        }
      },

      // returns index of document in a category Array of unsavedDocuments or -1 if documents doesn't exist in the Array.
      _computeUnsavedDocumentIndex: function (category, id) {
        if(!category) return console.error('no category provided');
        var unsavedDocumentsIds = this._getUnsavedDocumentIds(category);
        var index = unsavedDocumentsIds.indexOf(id);
        return index;
      },

      _removeUnsavedDocument: function(changeCategory, unsavedDocument) {
        var unsavedDocumentsIds = this._getUnsavedDocumentIds(changeCategory);
        var existingIndex = unsavedDocumentsIds.indexOf(unsavedDocument.id);
        this.splice('unsavedDocuments.' + changeCategory, existingIndex, 1);
      },

      _getUnsavedDocumentIds: function(changeCategory) {
        return this.unsavedDocuments[changeCategory].map(function(unsavedDocument) {
          return unsavedDocument.id;
        })
      },

      _fireErrorEvent: function (errorType, changeCategory, request) {
        var errorDocumentId = this._getDocumentIdFromAjaxRequest(updateRequest);
        var index = this._computeUnsavedDocumentIndex(changeCategory, errorDocumentId);
        var changedArray = this.unsavedDocuments[changeCategory];

        var errorDocument = changedArray[index] || {};
        this.fire( errorType + '-error', {'error': this._parseErrorObject(evt), 'document': errorDocument.doc, 'id': errorDocument.id});            
      },      

      // TODO add check for creations/deletions on interval
      _resetUpdateInterval: function(trackChanges, autoUpdate, updateInterval) {
        this._diffDocuments();
        window.clearInterval(this._updateTimer);
        if(!trackChanges) return;
        this._updateTimer = window.setInterval((function() {
          if(autoUpdate) {
            this.save();
          } else {
            this._diffDocuments();
          }
        }).bind(this), updateInterval);
      },

      _handleReadResponse: function(evt, data) {
        var documents = evt.target.lastResponse;
        this.set('documents', []);
        this.set('_shadowDocuments', []);
        for(var i=0;i<documents.length;i++) {
          this.push('documents', documents[i]);
          this.push('_shadowDocuments', JSON.stringify(this.documents[i]));
        }
        this.fire('read');
      }

      // TODO Update event documentation in crud-behavior (doc & id now also sent with error)

    });
  </script>
</dom-module>